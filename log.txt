package main

import (
	"context"
	"fmt"
	"io"
	"os/exec"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/muesli/reflow/wordwrap"
	"github.com/sashabaranov/go-openai"
	"github.com/spf13/cobra"
	"github.com/zalando/go-keyring"
)

type TerminalSize struct {
	Width  int
	Height int
}

// Define the model struct which includes the Bubbletea model elements
type model struct {
	openAIKeyInput textinput.Model
	openAISecret   string
	gitDiff        string
	commitMessage  strings.Builder
	errMsg         error
	hasOpenAIKey   bool
	viewport       viewport.Model
	spinner        spinner.Model
	isFetching     bool
	terminalSize   TerminalSize
}

// Implement the tea.Model interface for model
func (m *model) Init() tea.Cmd {

	return textinput.Blink
}

func (m *model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.terminalSize.Width = msg.Width
		m.terminalSize.Height = msg.Height
		println("width: ", m.terminalSize.Width)
		m.viewport.Width = msg.Width
		m.viewport.Height = msg.Height
		return m, nil
	case tea.KeyMsg:

		switch msg.Type {
		case tea.KeyCtrlC, tea.KeyEsc:
			println("Exiting...")
			return m, tea.Quit
		}
	}

	if !m.hasOpenAIKey {
		if m.openAIKeyInput.Value() != "" {
			switch msg := msg.(type) {

			case tea.KeyMsg:
				switch msg.Type {

				case tea.KeyEnter:
					println("Saving OpenAI key...")
					err := keyring.Set("crowdlog-aicommit", "anon", m.openAIKeyInput.Value())
					if err != nil {
						println("Error saving OpenAI key:", err)
					}
					m.hasOpenAIKey = true
					return m, cmd
				}
			}
		}
	}

	if m.hasOpenAIKey {
		switch msg := msg.(type) {
		case tea.KeyMsg:
			switch msg.Type {
			case tea.KeyEnter:
				cmd = someCmd(m)
				return m, cmd
			}
		case tickMsg:
			m.viewport.SetContent(m.commitMessage.String())
			m.viewport.GotoTop()
			return m, cmd
		}
	}
	m.openAIKeyInput, cmd = m.openAIKeyInput.Update(msg)

	return m, cmd
}

type tickMsg time.Time

func initialModel() model {
	ti := textinput.New()
	ti.Placeholder = "sk-..."
	ti.Focus()
	ti.CharLimit = 156
	ti.Width = 20
	service := "crowdlog-aicommit"
	user := "anon"

	var hasKey = false

	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("69"))

	secret, err := keyring.Get(service, user)
	if err != nil {
		hasKey = false
		return model{
			openAIKeyInput: ti,
			hasOpenAIKey:   hasKey,
			spinner:        s,
			terminalSize:   TerminalSize{Width: 0, Height: 0},
		}
	}
	println("secret: ", secret)
	return model{
		openAIKeyInput: ti,
		hasOpenAIKey:   true,
		openAISecret:   secret,
		spinner:        s,
		terminalSize:   TerminalSize{Width: 0, Height: 0},
	}
}

func (m *model) View() string {
	tea.LogToFile("log.txt", "hello")
	// Implement the logic to render the view based on the model state
	if m.errMsg != nil {
		return fmt.Sprintf("Error: %s", m.errMsg.Error())
	}

	if !m.hasOpenAIKey {
		return fmt.Sprintf(
			"No OpenAI key detected. Please enter it below:\n\n%s\n\n%s",
			m.openAIKeyInput.View(),
			"(esc to quit)",
		) + "\n"
	}

	var helpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("#FFFFFF")).Width(m.terminalSize.Width).Height(m.terminalSize.Height).PaddingTop(3)

	if m.isFetching {
		return fmt.Sprintf(
			"%s, %s", m.spinner.View(), helpStyle.Render(m.commitMessage.String()),
		)
	}

	return fmt.Sprintf("Commit Message: %s\n", helpStyle.Render(wordwrap.String(m.commitMessage.String(), m.terminalSize.Width)))
}

func main() {
	var rootCmd = &cobra.Command{
		Use:   "myapp",
		Short: "Git Commit Message Generator",
	}

	var cmdAICommit = &cobra.Command{
		Use:   "aicommit",
		Short: "Generate commit message using AI",
		Run:   runTea,
	}

	rootCmd.AddCommand(cmdAICommit)
	rootCmd.Execute()
}

func runTea(cmd *cobra.Command, args []string) {
	m := initialModel()
	p := tea.NewProgram(&m)
	go func() {
		for c := range time.Tick(20 * time.Millisecond) {
			if m.commitMessage.String() != "" {
				return
			}
			p.Send(tickMsg(c))
		}
	}()
	if _, err := p.Run(); err != nil {
		fmt.Println("Error running program:", err)
		return
	}

}

func getGitDiff() (string, error) {
	cmd := exec.Command("git", "diff", "head")
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return string(output), nil
}

func generateCommitMessageUsingAI(gitDiff string, m *model) (openai.ChatCompletionStream, error) {

	client := openai.NewClient(m.openAISecret)
	resp, err := client.CreateChatCompletionStream(
		context.Background(),
		openai.ChatCompletionRequest{
			Model: openai.GPT3Dot5Turbo,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleSystem,
					Content: "This is a commit message generator with a max length of 250 characters. Use conventional commits to describe your changes. ",
				},
				{
					Role:    openai.ChatMessageRoleUser,
					Content: gitDiff,
				},
			},
		},
	)
	if err != nil {
		return openai.ChatCompletionStream{}, err
	}
	return *resp, err
}

func someCmd(m *model) tea.Cmd {

	return func() tea.Msg {
		m.isFetching = true
		gitDiff, err := getGitDiff()
		if err != nil {
			println("Error getting git diff:", err)
			return nil
		}

		resp, err := generateCommitMessageUsingAI(gitDiff, m)
		if err != nil {
			println("Error generating commit message using AI:", err)
			return nil
		}
		m.commitMessage.Reset()
		for {
			resp, recvErr := resp.Recv()
			if recvErr == io.EOF {
				// End of the stream
				break
			}
			if recvErr != nil {
				println("Error receiving response:", recvErr)
				return nil
			}

			m.commitMessage.Write([]byte(resp.Choices[0].Delta.Content))

		}

		m.isFetching = false

		return nil
	}
}
